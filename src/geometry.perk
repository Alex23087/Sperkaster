import_local "includes.h"
open "vesacolour.perk"

struct Vec3 {
    let x: float = 0.0,
    let y: float = 0.0,
    let z: float = 0.0
}

struct Material {
    let type: int = 0, // 0 = solid, 1 = diffuse, 2 = reflective, 3 = refractive, -1 = normal, -2 = normal_attenuated, -3 = reflected direction, -4 = position
    let colour: VESA_Colour = make_VESA_Colour(255, 0, 0, 255),
    let refractive_index: float = 1.0,
    let diffusion: float = 0.5 // Only used for diffuse materials
}

struct Sphere {
    let radius: float = 1.0,
    let position: Vec3 = make Vec3(),
    let material: Material = make Material()
}

struct Mat4 {
    let m: [float 16] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
}

struct PerspectiveCamera {
    let eye: Vec3 = make Vec3(),
    let lookat: Vec3 = make Vec3(),
    let up: Vec3 = make Vec3()
}

struct Ray {
    let origin: Vec3 = make Vec3(),
    let direction: Vec3 = make Vec3()
}

struct LightSource {
    let position: Vec3 = make Vec3(),
    let intensity: float = 1.0,
    let colour: VESA_Colour = make_VESA_Colour(255, 255, 255, 255)
}

struct Parallelepiped {
    let min: Vec3 = make Vec3(),
    let max: Vec3 = make Vec3(),
    let material: Material = make Material()
}

fun vec3_add(a: Vec3, b: Vec3): Vec3 {
    return make Vec3(x = a.x + b.x, y = a.y + b.y, z = a.z + b.z);
}

fun vec3_sub(a: Vec3, b: Vec3): Vec3 {
    return make Vec3(x = a.x - b.x, y = a.y - b.y, z = a.z - b.z);
}

fun vec3_scale(v: Vec3, s: float): Vec3 {
    return make Vec3(x = v.x * s, y = v.y * s, z = v.z * s);
}

fun ray_at(ray: Ray*, t: float): Vec3 {
    return vec3_add((*ray).origin, vec3_scale((*ray).direction, t));
}

fun ray_sphere_intersection_point(ray: Ray*, sphere: Sphere*): Vec3? {
    let vecnone: Vec3? = none;
    let oc: Vec3 = vec3_sub((*ray).origin, (*sphere).position);
    let a: float = (*ray).direction.x * (*ray).direction.x + (*ray).direction.y * (*ray).direction.y + (*ray).direction.z * (*ray).direction.z;
    let b: float = 2.0 * (oc.x * (*ray).direction.x + oc.y * (*ray).direction.y + oc.z * (*ray).direction.z);
    let c: float = oc.x * oc.x + oc.y * oc.y + oc.z * oc.z - (*sphere).radius * (*sphere).radius;
    let discriminant: float = b * b - 4.0 * a * c;
    if (discriminant < 0.0) {
        return vecnone;
    };
    let sqrt_disc: float = fsqrt(discriminant);
    let t1: float = (-b - sqrt_disc) / (2.0 * a);
    let t2: float = (-b + sqrt_disc) / (2.0 * a);
    let t: float = if t1 >= 0.0 then t1  else t2;
    if (t < 0.0) {
        return vecnone;
    };
    return some ray_at(ray, t);
}

fun ray_sphere_hit_normal(ray: Ray*, hit_point: Vec3, sphere: Sphere*): Vec3 {
    let normal := vec3_normalized(vec3_sub(hit_point, (*sphere).position));
    return if vec3_dot(normal, (*ray).direction) > 0.0
        then vec3_scale(normal, -1.0)
        else normal;
}

fun camera_get_ray(cam: PerspectiveCamera*, u: float, v: float): Ray {
    let forward: Vec3 = vec3_sub((*cam).lookat, (*cam).eye);
    let right: Vec3 = vec3_cross(forward, (*cam).up);
    let up := (*cam).up;
    let direction: Vec3 = vec3_normalized(vec3_add(
        vec3_add(
            vec3_scale(right, u),
            vec3_scale(up, v)
        ),
        forward
    ));
    return make Ray(origin = (*cam).eye, direction = direction);
}

fun vec3_dot(a: Vec3, b: Vec3): float {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

fun vec3_cross(a: Vec3, b: Vec3): Vec3 {
    return make Vec3(
        x = a.y * b.z - a.z * b.y,
        y = a.z * b.x - a.x * b.z,
        z = a.x * b.y - a.y * b.x
    );
}

fun vec3_normalized(v: Vec3): Vec3 {
    let len: float = vec3_length(v);
    if (len == 0.0) {
        return make Vec3(x = 0.0, y = 0.0, z = 0.0);
    };
    return make Vec3(x = v.x / len, y = v.y / len, z = v.z / len);
}

fun ray_parallelepiped_intersection(ray: Ray*, para: Parallelepiped*): Vec3? {
    let vecnone: Vec3? = none;
    let tmin: float = ((*para).min.x - (*ray).origin.x) / (*ray).direction.x;
    let tmax: float = ((*para).max.x - (*ray).origin.x) / (*ray).direction.x;
    if (tmin > tmax) {
        let temp: float = tmin;
        tmin = tmax;
        tmax = temp;
    };
    let tymin: float = ((*para).min.y - (*ray).origin.y) / (*ray).direction.y;
    let tymax: float = ((*para).max.y - (*ray).origin.y) / (*ray).direction.y;
    if (tymin > tymax) {
        let temp: float = tymin;
        tymin = tymax;
        tymax = temp;
    };
    if ((tmin > tymax) || (tymin > tmax)) {
        return vecnone;
    };
    if (tymin > tmin) {
        tmin = tymin;
    };
    if (tymax < tmax) {
        tmax = tymax;
    };
    let tzmin: float = ((*para).min.z - (*ray).origin.z) / (*ray).direction.z;
    let tzmax: float = ((*para).max.z - (*ray).origin.z) / (*ray).direction.z;
    if (tzmin > tzmax) {
        let temp: float = tzmin;
        tzmin = tzmax;
        tzmax = temp;
    };
    if ((tmin > tzmax) || (tzmin > tmax)) {
        return vecnone;
    };
    if (tzmin > tmin) {
        tmin = tzmin;
    };
    if (tzmax < tmax) {
        tmax = tzmax;
    };
    if (tmin < 0.0 && tmax < 0.0) {
        return vecnone;
    };
    let t: float = if tmin >= 0.0 then tmin  else tmax;
    return some ray_at(ray, t);
}

fun ray_parallelepiped_hit_normal(ray: Ray*, hit_point: Vec3, para: Parallelepiped*): Vec3 {
    let epsilon: float = 0.0001;
    if (fabs(hit_point.x - (*para).min.x) < epsilon) {
        return make Vec3(x = -1.0, y = 0.0, z = 0.0);
    } else if (fabs(hit_point.x - (*para).max.x) < epsilon) {
        return make Vec3(x = 1.0, y = 0.0, z = 0.0);
    } else if (fabs(hit_point.y - (*para).min.y) < epsilon) {
        return make Vec3(x = 0.0, y = -1.0, z = 0.0);
    } else if (fabs(hit_point.y - (*para).max.y) < epsilon) {
        return make Vec3(x = 0.0, y = 1.0, z = 0.0);
    } else if (fabs(hit_point.z - (*para).min.z) < epsilon) {
        return make Vec3(x = 0.0, y = 0.0, z = -1.0);
    } else if (fabs(hit_point.z - (*para).max.z) < epsilon) {
        return make Vec3(x = 0.0, y = 0.0, z = 1.0);
    };
    return make Vec3(x = 0.0, y = 0.0, z = 0.0); // Default normal if none found
}

fun vec3_rotate(vector: Vec3, axis: Vec3, angle: float): Vec3 {
    let cos_theta: float = cos(angle);
    let sin_theta: float = sin(angle);
    return vec3_add(
        vec3_scale(vector, cos_theta),
        vec3_add(
            vec3_scale(vec3_cross(axis, vector), sin_theta),
            vec3_scale(axis, vec3_dot(axis, vector) * (1.0 - cos_theta))
        )
    );
}

// fun camera_look_at(cam: PerspectiveCamera*, target: Vec3): void {
//     (*cam).lookat = vec3_normalized(target);
//     let right := vec3_normalized(vec3_cross((*cam).lookat, (*cam).up));
//     (*cam).up = vec3_cross(right, (*cam).lookat);
// }

fun vec3_length(v: Vec3): float {
    return fsqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

fun vec3_length_squared(v: Vec3): float {
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

fun vec3_random(): Vec3 {
    return make Vec3(
        x = frand() * 2. - 1.,
        y = frand() * 2. - 1.,
        z = frand() * 2. - 1.
    );
}

fun vec3_random_in_unit_sphere(): Vec3 {
    while (true) {
        let p: Vec3 = vec3_random();
        let p_len_sq: float = vec3_length_squared(p);
        if (p_len_sq <= 1.0) {
            return vec3_scale(p, 1.0 / fsqrt(p_len_sq));
        };
    };
}

fun vec3_random_in_hemisphere(normal: Vec3): Vec3 {
    let in_unit_sphere: Vec3 = vec3_random_in_unit_sphere();
    if (vec3_dot(in_unit_sphere, normal) > 0.0) {
        return in_unit_sphere;
    } else {
        return vec3_scale(in_unit_sphere, -1.0);
    };
}

fun vec3_reflect(v: Vec3, n: Vec3): Vec3 {
    return vec3_sub(v, vec3_scale(n, 2.0 * vec3_dot(v, n)));
}

fun vec3_perturb(v: Vec3, magnitude: float): Vec3 {
    return make Vec3(
        x = v.x + (frand() * 2.0 - 1.0) * magnitude,
        y = v.y + (frand() * 2.0 - 1.0) * magnitude,
        z = v.z + (frand() * 2.0 - 1.0) * magnitude
    );
}