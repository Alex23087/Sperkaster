import_local "includes.h"
open "geometry.perk"

let hres: uint32_t = cast(uint32_t, 400)
let vres: uint32_t = cast(uint32_t, 400)
let pixel_size: float = 0.02
fun default_colour(): VESA_Colour {
    return make_VESA_Colour(0x90, 0xe3, 0xfc, 255);
}
let num_rays: int = 5
let num_bounces: int = 2
let ticks: int = 0

fun get_fb(w: Window*): Framebuffer* {
    let fb: Framebuffer* = cast(Framebuffer*, 0);
    BEGIN_C
    fb = (*w).fb;
    END_C;
    return fb;
}

fun get_width(w: Window*): size_t {
    let width: size_t = cast(size_t, 0);
    BEGIN_C
    width = (*w).width;
    END_C;
    return width;
}

fun get_height(w: Window*): size_t {
    let height: size_t = cast(size_t, 0);
    BEGIN_C
    height = (*w).height;
    END_C;
    return height;
}

fun cast_ray(ray: Ray*, spheres: [Sphere 3], parallelepipeds: [Parallelepiped 0], max_bounces: int): VESA_Colour {
    if (max_bounces <= 0) {
        return default_colour();
    };
    let hit: Vec3? = none;
    for (let i: size_t = cast(size_t, 0); i < spheres.length; i = i + 1) {
        hit = ray_sphere_intersection_point(ray, &spheres[cast(int, i)]);
        if (hit?) {
            let normal := ray_sphere_hit_normal(ray, hit!, &spheres[cast(int, i)]);
            let reflected_dir: Vec3 = vec3_reflect((*ray).direction, normal);
            let new_origin: Vec3 = vec3_add(hit!, vec3_scale(reflected_dir, 0.3));

            // return spheres[cast(int, i)].colour;
            // return make_VESA_Colour(cast(int, (normal.x + 1.) * 0.5 * 255.0), cast(int, (normal.y + 1.) * 0.5 * 255.0), cast(int, (normal.z + 1.) * 0.5 * 255.0), 255);


            // Colour by normal using angle to view direction
            // let intensity: float = fclamp(fabs(vec3_dot(normal, (*ray).direction)), 0.0, 1.0);
            // return make_VESA_Colour(cast(int, (normal.x + 1.) * 0.5 * 255.0 * intensity), cast(int, (normal.y + 1.) * 0.5 * 255.0 * intensity), cast(int, (normal.z + 1.) * 0.5 * 255.0 * intensity), 255);


            // Cast multiple rays for diffuse reflection
            let colour := make_VESA_Colour(0, 0, 0, 255);
            for(let i := 0; i < num_rays; i = i + 1) {
                let direction := vec3_normalized(vec3_perturb(reflected_dir, 0.2 * i));
                let sample := VESA_Colour_scale(
                    cast_ray(&(make Ray(origin = new_origin, direction = direction)), spheres, parallelepipeds, max_bounces - 1),
                    0.8 / cast(float, num_rays)
                );
                colour = VESA_Colour_add(colour, sample);
            };
            return VESA_Colour_multiply(colour, spheres[cast(int, i)].colour);


            // Cast a single ray for specular reflection
            // return VESA_Colour_multiply(
            //     VESA_Colour_scale(
            //         cast_ray(&(make Ray(origin = new_origin, direction = reflected_dir)), spheres, parallelepipeds, max_bounces - 1),
            //         0.8
            //     ),
            //     spheres[cast(int, i)].colour
            // );


            // Colour by normal
            // return VESA_Colour_from_vec3(normal);


            // Colour by reflected direction
            // return VESA_Colour_from_vec3(reflected_dir);


            // Colour by position
            // return VESA_Colour_from_vec3(hit!);
        }
    };
    for (let j: size_t = cast(size_t, 0); j < parallelepipeds.length; j = j + 1) {
        hit = ray_parallelepiped_intersection(ray, &parallelepipeds[cast(int, j)]);
        if (hit?) {
            let normal := ray_parallelepiped_hit_normal(ray, hit!, &parallelepipeds[cast(int, j)]);
            // return parallelepipeds[cast(int, j)].colour;
            return make_VESA_Colour(cast(int, (normal.x) * 0.5 * 255.0), cast(int, (normal.y) * 0.5 * 255.0), cast(int, (normal.z) * 0.5 * 255.0), 255);
        }
    };
    return default_colour();
}

fun juggle_balls(sphere: Sphere*, ticks: int): void {
    let pos_x: float = 20.0 * sin(cast(float, ticks) * 0.1);
    let pos_y: float = fabs(20.0 * cos(cast(float, ticks) * 0.1));
    (*sphere).position = make Vec3(x = pos_x, y = pos_y, z = (*sphere).position.z);
}


fun sperkaster(s: char*): void {
    if (!_vell_is_active()) {
        printf("You need to run vell\n");
        return;
    };

    let w: Window* = create_window_with_size("Sperkaster", hres, vres);
    set_window_dirty(w);

    fb_draw_rect(10, 10, get_width(w) - cast(size_t, 10), get_height(w) - cast(size_t, 10), cast(size_t, 1), make_VESA_Colour(255, 255, 255, 255), get_fb(w));

    let spheres: [Sphere 3] = [
        make Sphere(radius = 8., position = make Vec3(x = -20., y = 0., z = -50.0), colour = make_VESA_Colour(255, 0, 0, 255)),
        make Sphere(radius = 8., position = make Vec3(x = 0., y = 0., z = -50.0), colour = make_VESA_Colour(0, 255, 0, 255)),
        make Sphere(radius = 8., position = make Vec3(x = 20., y = 0., z = -50.0), colour = make_VESA_Colour(0, 0, 255, 255))
    ];

    let parallelepipeds: [Parallelepiped 0] = [
        // make Parallelepiped(min = make Vec3(x = -20., y = -20., z = -150.), max = make Vec3(x = 20., y = 20., z = -100.), colour = make_VESA_Colour(255, 255, 0, 255))
    ];

    let camera: PerspectiveCamera = make PerspectiveCamera(
        eye = make Vec3(x = 0.0, y = 0.0, z = 0.0),
        lookat = make Vec3(x = 0.0, y = 0.0, z = -1.0),
        up = make Vec3(x = 0.0, y = -1.0, z = 0.0)
    );

    let light_source: LightSource = make LightSource(
        position = make Vec3(x = 5.0, y = 5.0, z = 0.0),
        intensity = 1.0,
        colour = make_VESA_Colour(255, 255, 255, 255)
    );
    // Aspect ratio correction
    let aspect_ratio: float = cast(float, hres) / cast(float, vres);
    let fov: float = 60.0; // Field of view in degrees
    let fov_rad: float = fov * 3.14159 / 180.0;
    let scale: float = tan(fov_rad * 0.5);
    
    while (true) {
        for (let y: size_t = cast(size_t, 0); y < vres; y = y + 1) {
            for (let x: size_t = cast(size_t, 0); x < hres; x = x + 1) {
                // Normalize to [-1, 1] range first
                let x_norm: float = (cast(float, x) / cast(float, hres)) * 2.0 - 1.0;
                let y_norm: float = (cast(float, y) / cast(float, vres)) * 2.0 - 1.0;
                
                // Apply proper aspect ratio and field of view
                let u: float = -x_norm * aspect_ratio * scale;
                let v: float = y_norm * scale;

                let ray: Ray = camera_get_ray(&camera, u, v);

                let colour: VESA_Colour = cast_ray(&ray, spheres, parallelepipeds, num_bounces);

                fb_set_pixel(x, y, colour, get_fb(w));
            }
        };
        set_window_dirty(w);

        juggle_balls(&spheres[1], ticks);
        juggle_balls(&spheres[0], ticks + 20);
        juggle_balls(&spheres[2], ticks + 40);

        sleep(1);
        ticks = ticks + 1;
    }
}

fun fb_set_pixel(x: size_t, y: size_t, colour: VESA_Colour, fb: Framebuffer*): void {
    BEGIN_C
    if (x < (*fb).width && y < (*fb).height) {
        size_t index = y * (*fb).width + x;
        (*fb).fb[index] = colour.val;
    }
    END_C;
}