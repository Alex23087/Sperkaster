import_local "includes.h"
open "geometry.perk"

extern vga_fb: Framebuffer*

let pixel_size: int = 1
let hres: uint32_t = cast(uint32_t, 1270 / 1)
let vres: uint32_t = cast(uint32_t, 770 / 1)
let sky_colour: HDColour = make HDColour (r = 0x90 << 22, g = 0xe3 << 22, b = 0xfc << 22, a = 255 << 22)
let no_colour: HDColour = make HDColour (r = 0, g = 0, b = 0, a = 1073741823)

// Number of rays to cast per pixel
let num_rays: int = 50
// Number of times a ray can bounce
let num_bounces: int = 8
// Amount to scatter rays
let scatter_amount: float = 0.001
// Bias to avoid acne
let acne_bias: float = 2.
// Animation counter
let ticks: int = 0
let animate: bool = true
// Sleep between frames
let sleep_time: int = 1

fun get_fb(w: Window*): Framebuffer* {
    let fb: Framebuffer* = cast(Framebuffer*, 0);
    BEGIN_C
    fb = (*w).fb;
    END_C;
    return fb;
}

fun get_width(w: Window*): size_t {
    let width: size_t = cast(size_t, 0);
    BEGIN_C
    width = (*w).width;
    END_C;
    return width;
}

fun get_height(w: Window*): size_t {
    let height: size_t = cast(size_t, 0);
    BEGIN_C
    height = (*w).height;
    END_C;
    return height;
}

fun compute_colour (mat: Material, normal: Vec3, ray: Ray*, hit: (Vec3 * bool), spheres: [Sphere 3], parallelepipeds: [Parallelepiped 1], max_bounces: int): HDColour {
    let reflected_dir: Vec3 = vec3_reflect((*ray).direction, normal);
    let new_origin: Vec3 = vec3_add(hit[0], vec3_scale(reflected_dir, acne_bias));
    if (mat.type == 0) {                    // Solid colour
        return mat.colour;
    } else if (mat.type == 1) {             // Diffuse
        let direction := vec3_add(vec3_random_in_unit_sphere(), normal);
        let sample := HDColour_scale(
            cast_ray(&(make Ray(origin = new_origin, direction = direction)), spheres, parallelepipeds, max_bounces - 1),
            mat.diffusion
        );
        return HDColour_multiply(sample, mat.colour);
    } else if (mat.type == 2) {             // Specular reflection
        if (max_bounces == 1) {
            return mat.colour;
        } else {
            return HDColour_multiply(
                cast_ray(&(make Ray(origin = new_origin, direction = reflected_dir)), spheres, parallelepipeds, max_bounces - 1),
                mat.colour
            );
        }
    } else if (mat.type == 3) { // Refractive
        // Compute refraction using Snell's law
        let etai_over_etat: float = if hit[1] then mat.refractive_index else 1.0 / mat.refractive_index;
        let cos_theta: float = fmin(vec3_dot(vec3_scale((*ray).direction, -1.0), normal), 1.0);
        let sin_theta: float = fsqrt(1.0 - cos_theta * cos_theta);

        if (etai_over_etat * sin_theta > 1.0) {
            // Total internal reflection
            return HDColour_multiply(
                cast_ray(&(make Ray(origin = new_origin, direction = reflected_dir)), spheres, parallelepipeds, max_bounces - 1),
                mat.colour
            );
        };

        let r_out_perp: Vec3 = vec3_scale(vec3_add((*ray).direction, vec3_scale(normal, cos_theta)), etai_over_etat);
        let r_out_parallel: Vec3 = vec3_scale(normal, -fsqrt(fabs(1.0 - vec3_length_squared(r_out_perp))));
        let refracted: Vec3 = vec3_add(r_out_perp, r_out_parallel);

        return cast_ray(&(make Ray(origin = vec3_add(hit[0], vec3_scale(refracted, acne_bias)), direction = refracted)), spheres, parallelepipeds, max_bounces - 1);
    } else if (mat.type == -1) {            // Colour by normal
        return HDColour_from_vec3(normal);
    } else if (mat.type == -2) {            // Colour by normal using angle to view direction
        let intensity: float = fclamp(fabs(vec3_dot(normal, (*ray).direction)), 0.0, 1.0);
        return HDColour_scale(HDColour_from_vec3(normal), intensity);
    } else if (mat.type == -3) {            // Colour by reflected direction
        return HDColour_from_vec3(reflected_dir);
    } else if (mat.type == -4) {            // Colour by position
        return HDColour_from_vec3(hit[0]);
    };
    // return spheres[cast(int, i)].colour;
    // return make HDColour(r = cast( g =int, b = (normal.x a = + 1.) * 0.5 * colour_max0), cast(int, (normal.y + 1.) * 0.5 * colour_max0), cast(int, (normal.z + 1.) * 0.5 * colour_max0), 255);
    return sky_colour;
}

fun cast_ray(ray: Ray*, spheres: [Sphere 3], parallelepipeds: [Parallelepiped 1], max_bounces: int): HDColour {
    if (max_bounces <= 0) {
        return no_colour;
    };
    let hit: Vec3? = none;
    for (let i: size_t = cast(size_t, 0); i < spheres.length; i = i + 1) {
        hit = ray_sphere_intersection_point(ray, &spheres[cast(int, i)]);
        if (hit?) {
            let normal := ray_sphere_hit_normal(ray, hit!, &spheres[cast(int, i)]);
            let mat: Material = spheres[cast(int, i)].material;

            return compute_colour(mat, normal[0], ray, (hit!, normal[1]), spheres, parallelepipeds, max_bounces);
        }
    };
    for (let j: size_t = cast(size_t, 0); j < parallelepipeds.length; j = j + 1) {
        hit = ray_parallelepiped_intersection(ray, &parallelepipeds[cast(int, j)]);
        if (hit?) {
            let mat: Material = parallelepipeds[cast(int, j)].material;
            let normal := ray_parallelepiped_hit_normal(ray, hit!, &parallelepipeds[cast(int, j)]);

            return compute_colour(mat, normal[0], ray, (hit!, normal[1]), spheres, parallelepipeds, max_bounces);
        }
    };
    return sky_colour;
}

fun juggle_balls(sphere: Sphere*, ticks: int): void {
    let pos_x: float = 20.0 * sin(cast(float, ticks) * 0.1);
    let pos_y: float = fabs(20.0 * cos(cast(float, ticks) * 0.1));
    (*sphere).position = make Vec3(x = pos_x, y = pos_y, z = (*sphere).position.z);
}


fun sperkaster(s: char*): void {
    let in_vell: bool = false;
    let fb: Framebuffer* = cast(Framebuffer*, 0);
    let w: Window* = cast(Window*, 0);
    if (!_vell_is_active()) {
        in_vell = false;
        fb = vga_fb;
    } else {
        in_vell = true;
        w = create_window_with_size("Sperkaster", hres * pixel_size, vres * pixel_size);
        set_window_dirty(w);
        fb = get_fb(w);
    };

    let spheres: [Sphere 3] = [
        make Sphere(
            radius = 8.,
            position = make Vec3(x = 0., y = 0., z = -60.0),
            material = make Material(
                type = 2,
                colour = make HDColour(r = 200 << shift_amt, g = 250 << shift_amt, b = 200 << shift_amt, a = colour_max)
            )
        ),
        make Sphere(
            radius = 8.,
            position = make Vec3(x = -40., y = 0., z = -70.0),
            material = make Material(
                type = 3,
                colour = make HDColour(r = colour_max, g = colour_max, b = colour_max, a = colour_max),
                // colour = make HDColour(r = colour_max, g = 0, b = 0, a = colour_max),
                diffusion = 1.,
                refractive_index = 1. / 1.33
            )
        ),
        make Sphere(
            radius = 8.,
            position = make Vec3(x = 40., y = 0., z = -80.0),
            material = make Material(
                type = 1,
                colour = make HDColour(r = 0, g = 0, b = colour_max, a = colour_max),
                diffusion = 1.
            )
        )
        // make Sphere(
        //     radius = 1600.,
        //     position = make Vec3(x = 0., y = -1600., z = -800.0),
        //     material = make Material(
        //         type = 0,
        //         colour = make HDColour(r = 0x54, g = 0x3b, b = 0x0e, a = 255)
        //     )
        // )
    ];

    let parallelepipeds: [Parallelepiped 1] = [
        // Ground
        make Parallelepiped(
            min = make Vec3(x = -4000., y = -8., z = -4000.),
            max = make Vec3(x = 4000., y = -10., z = 4000.),
            material = make Material(
                type = 1,
                // colour = make HDColour(r = 0x40 << shift_amt, g = 0x60 << shift_amt, b = 0x40 << shift_amt, a = 255 << shift_amt),
                colour = make HDColour(r = 0xff << shift_amt, g = 0xff << shift_amt, b = 0x8f << shift_amt, a = 255 << shift_amt),
                diffusion = 1.
            )
        )
        // ,make Parallelepiped(
        //     min = make Vec3(x = -2000., y = -2000., z = -150.),
        //     max = make Vec3(x = 2000., y = 2000., z = -100.),
        //     material = make Material(
        //         type = 2,
        //         colour = make HDColour(r = 254, g = 254, b = 254, a = 255)
        //     )
        // )
        // ,make Parallelepiped(
        //     min = make Vec3(x = -2000., y = -2000., z = 150.),
        //     max = make Vec3(x = 2000., y = 2000., z = 100.),
        //     material = make Material(
        //         type = 2,
        //         colour = make HDColour(r = 254, g = 254, b = 254, a = 255)
        //     )
        // )
    ];

    let camera: PerspectiveCamera = make PerspectiveCamera(
        eye = make Vec3(x = 0.0, y = 10.0, z = -30.0),
        lookat = make Vec3(x = 0.0, y = 10.0, z = -31.0),
        up = make Vec3(x = 0.0, y = -1.0, z = 0.0)
    );

    let light_source: LightSource = make LightSource(
        position = make Vec3(x = 5.0, y = 5.0, z = 0.0),
        intensity = 1.0,
        colour = make HDColour(r = colour_max, g = colour_max, b = colour_max, a = colour_max)
    );
    // Aspect ratio correction
    let aspect_ratio: float = cast(float, hres) / cast(float, vres);
    let fov: float = 60.0; // Field of view in degrees
    let fov_rad: float = fov * 3.14159 / 180.0;
    let scale: float = tan(fov_rad * 0.5);
    
    let inverse_num_rays := 1.0 / cast(float, num_rays);

    juggle_balls(&spheres[1], ticks);
    juggle_balls(&spheres[0], ticks + 20);
    juggle_balls(&spheres[2], ticks + 40);

    ticks = ticks + 1;
    while (true) {
        for (let y: size_t = cast(size_t, 0); y < vres; y = y + 1) {
            for (let x: size_t = cast(size_t, 0); x < hres; x = x + 1) {
                // Normalize to [-1, 1] range first
                let x_norm: float = (cast(float, x) / cast(float, hres)) * 2.0 - 1.0;
                let y_norm: float = (cast(float, y) / cast(float, vres)) * 2.0 - 1.0;
                
                // Apply proper aspect ratio and field of view
                let u: float = -x_norm * aspect_ratio * scale;
                let v: float = y_norm * scale;

                let ray: Ray = camera_get_ray(&camera, u, v);
                let colour: HDColour = make HDColour();
                for (let r: int = 0; r < num_rays; r = r + 1) {
                    let ray_i: Ray = make Ray(origin = ray.origin, direction = vec3_normalized(vec3_perturb(ray.direction, scatter_amount)));
                    let sample := HDColour_scale(
                        cast_ray(&ray_i, spheres, parallelepipeds, num_bounces),
                        inverse_num_rays
                    );
                    colour = HDColour_add(colour, sample);
                };
                
                fb_set_pixel(x, y, colour, fb);
            };
        };
        if(in_vell) {
            set_window_dirty(w);
        };

        if (animate) {
            juggle_balls(&spheres[1], ticks);
            juggle_balls(&spheres[0], ticks + 20);
            juggle_balls(&spheres[2], ticks + 40);

            ticks = ticks + 1;

            // camera.lookat = vec3_rotate(camera.lookat, make Vec3(x = 0., y = 1., z = 0.), 0.05);
        };
        sleep(sleep_time);
    }
}

fun fb_set_pixel(x: size_t, y: size_t, colour: HDColour, fb: Framebuffer*): void {
    let colourVESA := HDColour_to_VESA_Colour(colour);
    BEGIN_C
    if ((x * pixel_size) < (*fb).width && (y * pixel_size) < (*fb).height) {
        if (pixel_size == 1) {
            size_t index = y * (*fb).width + x;
            (*fb).fb[index] = colourVESA.val;
            return;
        }
        for (size_t dy = 0; dy < pixel_size; dy = dy + 1) {
            for (size_t dx = 0; dx < pixel_size; dx = dx + 1) {
            size_t index = (y * pixel_size + dy) * (*fb).width + (x * pixel_size + dx);
            (*fb).fb[index] = colourVESA.val;
            }
        }
    }
    END_C;
}